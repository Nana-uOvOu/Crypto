# 密码学
# 第一章
## 计算机安全的核心目标： 
- 保密性(Confidentially)
  - 数据保密性：**隐私信息不被非授权者查看或使用**
  - 隐私性：确保个人能**控制或确定**哪些信息可以被收集和保存、谁能公开、向谁公开
- 完整性(Integrity)
  - 数据完整性：信息和程序只能**以授权的方式进行改变**
  - 系统完整性：确保系统以正常方式运行，**避免非授权操作**
- 可用性(Availability)：确保系统迅速反应，且**对授权用户不能拒绝服务**
以上统称为CIA原则
- 更多：
  - 真实性：要能够确保**可被验证和可被信任**，即能确保用户是他声明的那个用户、系统的输入都是来自可靠信源。
  - 可追溯性：每个实体的行为必须可**唯一追溯**到该实体。要能够追查到安全泄露的那一方。
## 缺失定义
- 保密性缺失：信息的非授权**泄露**
- 完整性缺失：信息的非授权**修改和毁坏**
- 可用性缺失：对信息与信息系统的**访问和使用的中断**
## 安全攻击
- 被动攻击：对传输进行**窃听和监测**
- 主动攻击：对数据流进行**改造或伪造**数据流
 - 伪装：伪装成另一个实体，例如截获有权限方的认证信息，完成认证后重放信息，即可获得额外权限。
 - 重放：将截获的信息再次发送
 - 消息修改：未经授权**修改合法消息**的某一部分、延迟消息传输、改变消息顺序。
 - 拒绝服务
## 安全服务
一种由系统提供的**对系统资源进行特殊保护**的处理或通信服务。安全服务通过安全机制来实现安全策略。
# 数论基础
## 整除性与带余除法
$b|a$:b整除a，b是a的因子；例如3|9、4|24
- 性质：
  - $a|1 -> a=\pm1$
  - $a|b且b|a -> a = \pm b$
  - $任何非0整数n|0$
  - $若b|g且b|h，则对于任意整数m、n，有b|(mg+nh)$
## 欧几里得算法
### 最大公因子gcd
gcd(a,b)，表示能同时整除a、b的最大整数，一定是正数。
- gcd(0,0) = 0
- gcd(a,b) = 1，则a、b互素
- gcd(a,b) = gcd(|a|,|b|)
- gcd(a,0) = |a|
### 欧几里得算法计算
gcd： 设$a\geq b > 0$，求解$d = gcd(a,b)$。
  1. 计算a与b的余数r1，得到$a = q_1b + r_1$
  2. 若$r_1 \neq 0$，则用b替换a，$r_1$替换b，计算$b = q_2r_1 + r_2$
  3. 若$r_2=0$，则$r_1$为最大公因子d
  - 即计算$d = gcd(r_1,r_2)$，若余数$r_3$为0则余数为$r_2$，否则$d=gcd(r_2,r_3)$
  ```Python
  def gcd(a,b):
    #递归算法
    r = a % b
    if r == 0:
        return b
    else:
        return gcd(b,r)
  ```
### 拓展欧几里得
- 同时计算出一个gcd(a,b)，且计算出$x、y$，使得$ax+by=gcd(a,b)$。其中x、y有着相反的正负号。
- 计算过程：
  1. 使用欧几里得算法计算d=gcd(a,b)，但记录下所有r（余数）和q（带余除法的结果）。
  2. 设$x_{-1}=1,y_{-1}=0,x_0=0,y_0=1$
  3. 计算$x_i=x_{i-2}-q_ix_{i-1}，y_i=y_{i-2}-q_iy_{i-1}$，对于每个i，都满足$r_i=ax_i+by_i$
  4. 计算到$i=n时r_{n+1}=0$，可以得到gcd(a,b)为$r_{n}$,要求的$x=x_n,y=y_n$。
- 利用拓展欧几里得求逆元：在模n下a的逆元x，若$ax \equiv 1(\mod n)，则ax = bn + 1，则ax+bn=1。$则可以用于计算a、n互素时，a的逆元(**只有当a、n互素时才有逆元**)：直接计算extended_gcd(a,-n)，得到的x就是a的逆元。
- ```Python
  def extended_gcd(a,b):
      x = [1,0]
      y = [0,1]
      i = 2
      r = 1
      while r != 0:
          r = a % b
          q = a // b
          if r == 0:
              return b, x[len(x)-1], y[len(y)-1]
          a = b
          b = r
          x.append(x[i-2] - q * x[i-1])
          y.append(y[i-2] - q * y[i-1])
          i += 1
  ```
## 模运算mod
$a/n = q 余 r$，r即为$ a \mod n $
### 同余
- 若$a\mod n = b\mod n$，称为a、b模n同余。记为$a\equiv b(\mod n)$
- $a\equiv 0(\mod n)，则n|a$
- 性质:
  - 若$n|(a-b)，则a \equiv b (\mod n)$
  - 若ab模n同余、bc模n同余，则ac模n同余
  - $a \equiv b (\mod n)则b \equiv a (\mod n)$
  - 若$(a+b) \equiv (a+c) (\mod n)，则b \equiv c (\mod n)$
  - **当a与n互素时**，若$(a×b) \equiv (ac) (\mod n)，则b \equiv c (\mod n)$。原因：如果a与n互素，则$Z_n$中的所有数乘以a可以得到完整的$Z_n$，而如果不互素，则得不到完整剩余类集。
### mod运算性质
- $(a+b) \mod n = (a \mod n + b \mod n) \mod n$
- $(a-b) \mod n = (a \mod n - b \mod n) \mod n$
- $(a×b) \mod n = (a \mod n × b \mod n) \mod n$
### 模运算中定义：
- 负数（加法逆元）：a的负数b满足：$a+b = 0$。例如在模8运算中，3的负数是5。在加法运算表中，**所有0元素对应的行列互为加法逆元**。
- 倒数（乘法逆元）：a的乘法逆元满足：$a×b = 1$。例如在模8运算中，3的乘法逆元为3。在乘法运算表中，**所有1元素对应的行列互为乘法逆元**。#注：并非所有元素都有乘法逆元。
### 剩余类
n的剩余类（集）：$Z_n = \{0,1,2,...,n-1\}$，定义为小于n的所有非负整数。剩余类表示为$[0]、[1]、...、[n-1]$，其中$[r] = \{a:a为整数，且a \equiv r (\mod n)\}$，但一般直接用$r$表示剩余类。
## 素数
- 任何整数a>1，都可以分解为多个素数的乘积：$a=p_1^{a_1}×p_2^{a_2}...×p_n^{a_n}$
- $a=\prod p^{a_p}，b=\prod p^{b_p}$，其中$p$是某个整数，而$a_p$表示整数的指数，若$a|b$，则有$a_p \leq b_p$
- 若$k = gcd(a,b)，那么k_p=min\{a_p,b_p\}$
## 费马定理与欧拉定理
### 费马定理
- 若p是素数，且p不能整除a，则$a^{p-1} \mod p 余数永远为1$。即$a^{p-1} \equiv 1 (\mod p)$
- 若p是素数，a是**任意正整数**，则有$a^p \equiv a (\mod p)$
### 欧拉函数
- $\phi(n)表示小于n且与n互素的元素个数，\phi(1)=1,\phi(4)=count([1,3]=2)$
- 对于一个素数p，总存在$\phi(p)=p-1$
- 对于素数p、q，n=pq有$\phi(n)=\phi(pq)=\phi(p)\phi(q)=(p-1)(q-1)$
- 欧拉定理：
- 对于任意互素的$a、n$，存在$a^{\phi(n)} \equiv 1 (\mod n)$
- 对于任意互素的$a、n$，存在$a^{\phi(n)+1} \equiv a (\mod n)$
- 中国剩余定理：
- 求解一元线性同余方程组：对于一个物品有c个， 每组p1个数剩r1，每组p2个数剩r2...
### 中国剩余定理形式
![img_1.png](img_1.png)
1. 将原问题分解为：$X=X_1+X_2+...+X_n$，其中$X_1 \mod p_1 = r1$，而$X_1 \mod p都为0$；$X_2 \mod p_2 = r_2$,$而X_2 \mod其他p均为0......$
2. $将X_i转换为Y_i，其中，Y_i \mod p_i = 1$，而mod任意其他均为0，则需要求解的数字$X=\sum Y_i×r_i$
3. 由于$Y_i \mod 任意其他p均为0$，则$Y_i = k_i * \prod_{k,k\neq i} r_i$。由于$Y_i \mod p_i = 1$，则有$k_i * \prod_{k,k\neq i} r_i \equiv 1 (\mod p_i)$，则就是求$Y_i在模p_i下的逆元$
    ```Python
    import euclid_gcd as g
    def china(rs,ps):
        #转换为求解逆元的过程
        X = 0
        for i in range(len(rs)):
            y_e = 1
            for j in range(len(rs)):
                if j != i:
                    y_e *= ps[j]
            _,k,_ = g.extended_gcd(y_e,ps[i])
            X += rs[i] * k * y_e
        return X 
    ```

## 素数判断
- Rabin-Miller算法
  - 随机选取一个a，一次遍历后通过测试的概率是$\frac{1}{4}$
    - 首先对于一个**奇整数n**，可以分解为n-1=$2^kq$，其中$q$是奇数。
    - 随机选取一个$a(1<a<n-1)$
    - 从$j=[1,k-1]$开始计算，若j=1时，$a^{2^jq}=a^{q} \mod n=1$，则返回**不确定**
    - 若$j \neq 1$，若存在$a^{2^jq} \mod n = n-1$，则返回不确定
    - 遍历完所有$j$后仍未返回不确定，则就是合数。
  - 选取多个不同的随机a进行测试，t次遍历后一个合数仍能通过测试的概率为$(\frac{1}{4})^t$
  
  ```python
  import random
  def rabin_miller(n,t):
    if n % 2 == 0:
        print(f"{n}是合数")
    #随机选取t个a
    aa = []
    while len(aa) < t:
        rint = random.randint(2,n-2)
        if aa.count(rint)==0:
            aa.append(rint)

    #将奇整数分解
    k = 1
    while int((n-1) / (2 ** k)) % 2 == 0:
        k += 1
    q = int((n - 1) / (2 ** k))

    #j = 0时，查看是否a^q mod n为1
    for a in aa:
        flag = False
        if (a ** q) % n == 1:
            flag = True
        if not flag:
            for j in range(0,k):
                if (a ** ((2 ** j) * q)) % n == n-1:
                    flag = True
                    break
        if not flag:
            print(f"{n}是合数")
            return
    print(f"在{t}次测试下，{n}均通过测试，可能是素数") 
  ```

# 群论基础
抽象代数中，考虑**元素进行代数运算的集合**
![群-环-域](image-8.png)
- 根据元素个数是否有限，分为有/无限群环域
- **阶数**：群/环/域内元素个数
## 群
群是一个**二元运算**的集合。记作$G\{G,·\}$。$G$是一个元素集合，$·$是一个运算。
- **群**有如下性质：  
  1. (加法)封闭性A1：若$a,b \in G$，则$a · b \in G$。即两元素运算后的结果仍然在群中。
  2. (加法)结合律A2：$a · (b · c) = (a · b) · c$
  3. (加法)单位元A3：存在一个单位元$e$，使得任意$a \in G$有$a · e = e · a = a$
  4. (加法)元A4：对于任意$a \in G$，存在一个$a' \in G$，使得$a · a' = e$
- **交换群**有如下性质：
  1. 是一个群A1-A4
  2. (加法)交换律A5：$a · b = b 成
- \*循环群有如下性质：
  - 定义幂运算$a^k = a · a ·...$;$a_0 = e$;$a_{-k}=a'^k$
  1. 是一个群，群中只由一个元素$a$以及$a^k$组成。一定是交换群。
## 环
环有两个二元运算，记作$R=\{R,+,×\}$。在环上进行加减乘不脱离集合。
- **环有**如下性质：
  1. $R$关于加法是一个交换群，即满足A1-A5
  2. 乘法封闭性M1
  3. 乘法结合律M2：$a × (b × c) = (a × b) × c$
  4. 乘法分配律M3：$a×(b+c)=a×b+a×c$
- **交换环**有如下性质：
  1. 是一个环：A1-A5，M1-M3
  2. 乘法交换律：M4
- **整环**有如下性质：
  1. 是一个交换环
  2. 乘法单位元M5**1**
  3. 无零因子M6：存在一个0，使得如果$a × b = 0$，则必有$a = 0或b = 0$
## 域
域有两个二元运算，记作$\{F,+,×\}$。在域中进行加减乘除而不脱离域。
- **域**满足：
  1. 是一个整环。A1-A5，M1-M6
  2. 乘法逆元
## 总结图
![群-环-域总结](image-9.png)
## 有限域GF(p)
- GF(p)定义为整数$\{0,1,2,3...,p-1\}$的集合$Z_p$，其中**p是一个素数**，加乘要模p。
- 最有意义的是GF(2)，在GF(2)中，加法等同异或，乘法等同逻辑与。
### 乘法逆元
- 对于$Z_p$中的任意一个整数a，其**有乘法逆元的条件是$a$与$p$互素**。当p是素数时，所有$Z_p$中的非零整数都与$p$互素，则每个非零元素都有乘法逆元（**在mod p 条件下**）。
- $Z_p$上求乘法逆元：
  1. p值小，则直接构造一个乘法表，取得数为1的行列。
  2. 拓展欧几里得算法：
    - 若$b$与$p$互素，即$gcd(b,p)=1$，则可知在$Z_p$上$b$一定有乘法逆元$b' < p$。
    1. 此时要计算$b$在$\mod p$下的乘法逆元，可以构造函数：$(px + by) \mod p = gcd(b,p) = 1$
    2. 得到$px \mod p + by \mod p = 0 + by \mod p = gcd(b,p) = 1$
    3. 使用扩展欧几里得算法，得到的$y$就是b的乘法逆元$b'$
### 多项式运算
$f(x) = \sum{i}^{n} a_ix^i$;其中$a_i$称为系数集S,$a_n \neq 0$。若$a_n = 1$，则称为**首一多项式**。
- 系数集S是环，则不一定有除法定义，可能导致不能整除；系数集S是**有限**域，也不一定整除。定义有限域S内的多项式除法如下：
  - 一个$n$次多项式$f(x)$，$m$次多项式$g(x)$，计算$frac{f(x)}{g(x)}$，商式为$q(x)$，余式$r(x)$，则得到一个带余数的式子$f(x) = q(x)g(x) + r(x)$。
  - 如果允许存在余数$r(x)$，则称有限域F内多项式除法是**可能的**。将余式记作$r(x) = f(x) \mod g(x)$；若$r(x) = 0$，则$g(x)$整除$f(x)$，记作$g(x)|f(x)$
- 如果系数域F中某个多项式$f(x)$**不能表示为任何F中其他多项式的乘积**，则称$f(x)$为素多项式。
- 多项式加减乘除：![多项式加减乘除](image-10.png)
### 求最大公因式
类似普通的欧几里得算法，有$gcd(f(x),g(x))=gcd(g(x),f(x) \mod g(x))$并辗转相除
## 有限域$GF(2^n)$
### 为什么要引入$GF(2^n)$
- 原因：计算机中的n位字，希望可以构造一个域，元素范围在$0-2^{n}-1$。然而，普通的$GF(2^n)$，并不是一个域，因为$2^n$不是一个素数。则额外在系数为$GF(2)$的n项的多项式上定义一个$GF(2^n)$,有如下性质![GF(2^3)](image-11.png)。
- 优势：是一个域，每一个元素在加减上都有逆元。且在加减乘除运算中，每个元素出现次数是均匀的，适合密码算法。
### **多项式的模运算**
- $GF(p^n)$，是所有由系数是$Z_p$，且有n项的多项式组成的集合（如$p=2,n=3$，则有8个项）。要满足域条件，需要满足：
  1. 加与乘满足普通多项式运算规律。
  2. 系数运算以p为模，即系数在$Z_p$中。
  3. 乘法运算结果的最大次数$\leq n-1$，若超过则要使用一个n次(n+1项)不可约多项式$g(x)$(某个素多项式)取模。即$f'(x) = r(x) = f(x) \mod g(x)$
- 在不可约多项式的模下，可以使用扩展欧几里得算法计算某个多项式的乘法逆元：
  1. 对于一个不可约n次多项式$g(x)$，一定有$f(x) \in GF(2^n)$，使得$gcd(f(x),g(x))=1$
  2. 则有$f(x)×\phi_1(x) \mod g(x) + g(x)×\phi_2(x) \mod g(x) = 1$，即$f(x)×\phi_1(x) \mod g(x) = 1$，计算的$\phi_1(x)$就是$f(x)$的乘法逆元。
# 分组密码
通常用16进制表示
## Feistel密码体制
- DES、CAST、BlowFish密码等
- 轮询密码。将输入分为两组进行加密。这个过程类似异或，是可逆的。**将输出两组互换作为输入重新计算一次就会变回来**。
![Feistel密码过程](Feistel.png)
![Feistel密码全过程](image-1.png)
- 特点：计算快捷方便。不要求轮函数可逆，基于伪随机。有多轮；每轮有异或等可恢复操作；有**轮函数**。
- 轮函数设计原则：
    1. 非线性越多越难进行差分分析
    2. 有效性分析：
        1. SAC严格雪崩准则：要求S盒输入任何一位发生变化，输出只要一半变化。
        2. 没看清QWQ
## DES算法(Feistel体制)
分组长度：64比特；密钥长度：56比特（密钥加长难以穷举）；轮数：16（轮数增加难以密码规律分析）
### DES流程：
#### 总体结构
![DES总体结构](DES总体结构.png)
#### DES初始化操作
1. 将文本转变为二进制数形式。分为64位的多个组Group；如果某个组不足64位，则需要补0padding。
2. 将每个组放入IP初始置换中进行置换。IP类似洗牌，固定可逆，有一张IP置换表，表中数字i表示用第i个index的值替换。[IP](image-2.png)
#### DES轮加密操作
1. 每一轮会将64位组分为$L_iR_i$左右32位两部分。
2. 首先，将$R_i$进行拓展置换为48位；
 通过原56bit的密钥生成一个48位的子密钥$K_i$。计算48位的$R_i \oplus K_i$。
  - R的扩展：![R的扩展盒](image-4.png)
  - 密钥调度算法(Key Schedule Algorithm)：将64位主密钥(其中8位是奇偶校验位，不起加密作用)分为16个48位子密钥。
      - ![密钥调度算法](image-5.png)
      - 置换1(PC1)：![PC-1](image-6.png)。丢弃每8位的最后一位，即奇偶校验位。
      - 置换2(PC2)：![PC-2](image-7.png)
1. 将$R_i \oplus K_i$放入**非线性S盒**中，将48位映射到32位，是一个压缩函数。    
  - S盒：![DES的S盒](DES的S盒.png)
  - S1盒 ![S盒表](image.png)
2. 再将S盒输出的32位放入P盒中置换，得到轮密钥RoundKey。将$RK$与$L_i$异或后得到下一组的$R_{i+1}$。将原$R_i$直接放到$L_{i+1}$即完成一轮加密。
- 末置换FP：是IP的逆过程。![FP](image-3.png)
#### DES有雪崩效应
一个密钥位或明文位bit变化导致密文至少1/2变化。这种变化的大量传播效应称为**差分Differential**。密码机制设计时要求差分快、广。
#### 缺陷以及改进
密钥空间太小。
##### 2/3DES
3DES:2/3个不同密钥，进行加(E)解(D)密，如E(k1)D(k2)E(k1/k3)、DED,解密时需要反过来DED、EDE。增大了密钥空间但没有增大分组大小，分组空间置换时仍然有限制。
然而，2/3DES中，已证明DES不是一个群，即加法（2DES、3DES）后不在原DES中，不能直接映射到1-DES。
多用于应用层协议，如PGP或SMTP
###### 中间人攻击
对于2-DES，有$p→_{(Des_1)}X_1→_{(Des_2)}c$，当中间人得到$p$和$c$时，穷举左侧加密DES(p)($2^56$)得到$X_1$，穷举右侧解密DES(c)($2^64$)得到了一个$X_2$，若$X_1=X_2$，则大概率得到了密钥$K_1,K_2$
###### 解决方法
可以使用更高安全的算法叠，例如第一次加密使用DES（2*64位），第二次加密使用AES（128位）
###### 中间相遇攻击
MITM(Meet in the middle)
在点到点链路上，每个点node都可能被攻击（如PPTP的VPN）。而用户希望端到端的安全。则需要保证每个点安全。
不依赖任何分组密码的性质，适用于任何密码。
###### 流程
在Internet上传输数据时，在某个节点（node）进行监控和修改。
## AES算法
SPN Structure 十轮(若是16字节子密钥)；密钥长度128/192/256位；分组长度128bits。所有加减乘除运算都是在$GF(2^8)$上定义的。
- GF群：
    - 普通群中，可能存在某些数没有乘法逆元，为了解决这个问题定义$GF(2^n) = sum{0}{n-1}{a_i*2^i}$的一个多项式，$a_i$仅取0，1；则整个群中有$2^n$个元素。
    - 系数运算以2为模；当乘法运算后多项式次数超过了n-1，则需要用一个不可约多项式m(x)（不能被次数小于m(x)的两个多项式来乘法表示，有多个，可任选，但运算效率不同）来取模。
    - **所有运算都是对于多项式的运算，只不过显示为系数**
- 算法输入：128位的分组，即16字节，**将16字节分成一个4×4矩阵**，按列排序，前4字节放在第一列，4-8第二列...。
- ![AES算法](AES算法.png)
### 密钥生成
- m位密钥变为方阵，初始变换和每轮都选取一个16字节（128位）的4×4方阵作为子密钥。
- 密钥拓展：输入一个4字(16字节)主密钥的4×4方阵，输出一个44字的矩阵:11×4，为初始变换和10轮提供子密钥。
### 算法解释
- 开始轮函数前和结束后，需要用一个子密钥先进行依次KeyAdd，引入随机性：前/后期白化，加入白噪声。
- 一个轮函数是可逆的，有四层。
    1. 字节代换(S盒子SBox):
        1. 唯一一个非线性的函数。
        2. 在$x 属于 GF(8)$中，$y=f(x) = x^{-1}(x的逆元) = x^{254} mod 不可约多项式$(在GF(8)下)。则选取一个不可约多项式，所以可以构造一个SB表，表头为${X,X^_{-1}}$，则只需要256字节表。$x^{-1}(x的逆元) = x^{254}$原因：$x × x^{254} = 1$(即e单位元)
        3. ![AES的SBox表](AES的SBox表.png)
    2. Shift Row置换层(只涉及到矩阵旋转，是对于一行的循环。从第一行开始循环左移0,1,2,3...。不改变值只改变位置)
    3. 列混淆变换Mix Col层：有一个列混淆矩阵U，一个逆矩阵W：WU=E（单位矩阵）；则原矩阵S混淆$S' = US$；逆变换$S = WS$。不仅变换了位置(置换)，也进行了混淆。
    4. 密码加KeyAdd:可逆层，$y <- x \oplus sk_n$；$x <- y \oplus sk_n$
- 最后一轮没有Mix Col
### 加密效果
- 雪崩效应：很强，明文或密钥的任何bit改变影响密文所有字节。在没有密钥时看上去完全随机。
### 算法实现
- AES加解密过程是不同的，置换ShiftRow和列混淆的混淆矩阵不同，需要不同的函数软件实现。
- 需要两步操作：
    1. 交换解密算法的字节替换和逆向Shift Row两层
    2. 交换解密算法的轮密钥加(KA)和逆向列混淆(MC)两层：$MixCol^{-1}(S \oplus Key) = MixCol_{-1}(S) \oplus MixCol_{-1}(Key)$
## 分组密码分析
对于2-DES，中间人攻击复杂度$2*{2^56}$，而直接穷举时复杂度$2^{56 * 2}$，差距很大。即不同攻击方法的效率差距极大。
### 差分分析（不理解）
选择明文攻击，典型的统计分析方法。
#### 基本思想
**对某些明密文对，分析多个明文对之间的差距，统计密文对的差异，恢复某些密文。**对于明文对$p_1p_2$，计算$\Delta_p = p_1 \oplus p_2$，$\Delta_f = f(p_1) \oplus f(p_2)$。分析两个差异，尝试恢复部分key。**实际上只关心$\Delta$，即明密文对的差分，不关心实际明密文对**
在DES的差6轮中，差分分析的搜索空间很大。
#### 查分过程
![alt text](image-12.png)
对于明文对差分$x_1\oplus x_2$，某一轮中$L_1$直接放入$R_2$,得到差分结果是1；$R_1$经过$L1 \oplus f(x_1) \oplus f(x_2) \oplus k_1$，当别的不变，只改变K时，以另一概率(0.25)出现另一个差分$L_2$。经过三轮DES后，从输入差分变为输出差分后概率为0.25×1×0.25。**攻击时挑选概率最大的差分对应的Key即可**。
#### 差分均匀
如果无论改变key的值，所有输出差分的概率都是一样的，那就完全安全，差分分析不可用。
### 线性分析
已知明文攻击
#### 基本思想
寻找明文、密文、密钥比特之间对高概率或低概率的**线性逼近**，尝试恢复某些密钥的比特位。
#### 分析过程
设计一个线性过程，概率逼近加密过程中的**非线性部分**。以DES为例，计算$\Delta X=linear(x) \oplus f_k(x)$，降低$\Delta X$的Hamming重量（1比特数量）。复杂度极高。
### 侧信道攻击
Side-Channel Attack，SCA
利用密码系统的物理实现中获取的物理特征进行密码分析。分析运行时间、功率消耗、电磁辐射、声音等。
### 故障攻击
Falut Attack，FA
在密码系统的物理实现中加入**干扰**，使得生成故障的密文或签名，利用故障信息进行分析。
利用密文c，故障密文c‘进行分析。
## 分组密码的工作模式
工作模式是指：增强密码算法或使**得密码算法适应实际应用的技术**。
目前定义了五种工作模式,覆盖了大部分实际应用场景。类似一种建房子的安全模式,必须按照这种方式建。
### 模式分类
1. 加密模式
   1. 存储设备加密模式：Windows的Bitlocker
   2. 格式保留加密方法：FPE，Format Preserving Encryption。例如数据库中定义的字段，加密后变混乱不能识别，且熵增可能放不下。
2. 认证加密模式
3. 认证模式
   1. 高吞吐率认证
4. 密钥封装方法
### 工作模式评估
1. 安全性能：抗攻击能力、加密保密能力
2. 实现特性：并行能力、单元复用，实现安全的效率和成本
3. 错误恢复
4. 错误传播：一bit错误翻转对密文恢复的影响
5. 扩散能力
6. 消息膨胀：填充
### 电码本模式（ECB Electronic CodeBook Mode）
用相同密钥加密明文消息的每个划分小部分。$明文分组1→^{Key} 加密分组1、明文分组→^{Key}加密分组....$
##### 加解密流程
报文padding为整数倍的分组长度，再分割为多个小分组，每个单独用同一个Key加密。
##### 优缺点
1. 优点：并行加密、随机存取
2. 缺点：需要明文填充，相同明文分组对应相同的密文，有统计规律，例如对一张图像加密，按顺序加密后会保留轮廓和特点。可能被重排、篡改、替换
##### 错误传播仅局限在分组内
### 密文分组链接模式CBC加密(Cipher Block Chaining)
![alt text](image-13.png)
##### 加密流程
1. 对于第一个分组，随机生成一个初始化向量IV（长度与分组大小相同），对第一个分组进行异或加密，再使用Key密钥和分组加密算法加密分组1。
2. 对于第$i$个分组($i>1$)，使用第$i-1$个分组的密文与其明文进行异或，再使用Key和分组加密算法加密。
##### 解密流程
1. 第$i$个分组使用密钥解密，解密后用第$i-1$个分组密文异或得到明文。
2. 若$i=1$，则解密后用IV异或解密。
##### 优缺点 
1. 优点：避免了明文特征重复，减弱统计特征。可用于认证。
2. 缺点：只能串行加密，吞吐量不高。但解密可以并行。仍然需要Padding。若所有明文加密都使用一个Key和一个IV,不随机选择IV，则会有问题（**考试会考哦~**）:
   1. 相同IV导致相同的密文，导致重放攻击。
   2. 已知明文攻击：若已知明密文对，就可以从中求解IV和密钥Key的相关信息
##### 错误传播
加密时，第$i$组密文的比特翻转会影响i和i后面的所有组。
解密时，第$i$组密文的比特翻转仅会影响i和i+1组。适合用于**认证**，即确保完整性。
### 密码反馈模式CFB Cipher Feedback mode
将上一块的密文输出用K加密，和当前明文异或，作为当前的明文输出。
CBC Chain链式，将本块明文和上块密文异或再加密： $C_i ← E_k(P_i \oplus C_{i-1})$ 
CFB 密码反馈，将上一块密文加密，反馈（异或）到这一块的明文。$C_i ← E_k(C_{i-1}) \oplus P_i$
##### 加密流程
![alt text](image-14.png)
分组长度s bits
1. 初始随机IV(b bits)作为$I_1$，用K加密，得到了加密密钥O(b bits)，随机选择s bits的加密密钥，与明文$P_1$异或，得到密文$C_1$。
2. 存储密文$C_1$，使用移位寄存器移位得到b bits的$I_2$，重复上述过程。
##### 解密流程
![alt text](image-15.png)
1. 用IV加密生成第一组加密密钥O，选择s bits密钥后与$C_1$异或，得到第一组明文。
2. 第$i$组使用第$i-1$组的密文$C_{i-1}$加密得到O，O选择出加密密钥，与$C_i$异或得到明文$P_i$
##### 优缺点
1. 不能并行加密，可以并行解密
2. **不需要解密算法**，只需要K和IV/上一组密文的加密算法。
##### 错误传播
加密：一个密文翻转传播到当前和所有后面的分组
### 输出反馈模式OFB(Output Feedback Mode)
##### 加密流程
![alt text](image-16.png)
1. 一个随机数Nonce，与密钥K加密得到密钥$O_1$；再i加密得到$O_2,O_3,...,O_n$。只加密Nonce的输出。
2. 对于每个明文$P_i$，使用$O_i$异或得到密文$C_i$。
##### 解密流程
重新计算所有密钥$O_i$，将密文$C_i$重新异或就得到明文$P_i$
##### 优缺点
1. 如果预计算$O_i$，就可以并行加解密。
2. 没有错误扩散，但对抗主动攻击的能力很差。
##### 错误传播
加解密的翻转只影响当前组。
##### OFB和CFB区别
![alt text](image-17.png)
### 计数器模式CTR
高速并行预计算
![alt text](image-18.png)
## 分组密码对比
![alt text](image-19.png)
## 分组密码的膨胀
某些应用领域不能使用带膨胀的方案。 
### 填充问题
分组密码的最后一块大小$\leq$block size。如果使用0padding，则不知道最后一个0是填充的还是实际的。解决方法：通常以字节长度来填充。**最少padding膨胀1字节，最多padding膨胀整个blocksize字节数**
- 例如，AES有64位16字节，若只有5字节，需要补充11字节=0x0B的0。补充方法：最后11字节填充0x0b个0x0b，de-padding时，从最后一位0x0b开始扫描，扫描0x0b个，如果中途不连续则出错/有攻击...
- 如果不需要填充（长度恰好是blocksize的整数倍），则仍然要加一个padding分组，消除二义性，整一个0x0F个0x0F字节最后一组。
### 是否存在无膨胀的方案？密文挪用技术CTS:Ciphertext Stealing Technique
用于处理分组密码中，分组长度不能均匀分割的消息，不产生任何膨胀，但增加一点复杂度。
##### 处理方法
前面的分组按照正常模式处理，将最后两个明文分组的处理顺序调换，并对最后两个密文分组重排序（Reorder processing）。称为CTS-CBC/CTS-ECB。
![alt text](image-20.png)
![alt text](image-21.png)
先加密$p_{n-1}$，得到的$c_{n-1}$作为密文的$c_n$储存；再加密$p_n | c'$，得到的$c_{n}$作为$c_{n-1}$
###### 加密
1. 第$p_{n-1}$个分组正常加密得到$c_{n-1}$
2. 利用$p_n$长度$|p_n|$将$c_{n-1}$切割，前一部分$c_n$,长度为$|p_n|$，后一部分为$c'$,长度为$|c_{n-1}|-|p_n|$，则$c'$的长度正好和$p_n$需要的padding长度一致。将$c'$拼接到$p_n$后，再进行加密。存储密文时将其反过来,**可以丢弃最后一个分组的C'**，最终导致不膨胀。
3. 无论多长的数据，最终需要的额外处理就是一个常数级别的分割C'操作，所以效率很高。
###### 解密
1. 解密$C_{n-1}$得到$p_n$，解密$C_{n}$得到$p_{n-1}$
### 可调分组密码Tweakable Block Cipher 简称TBC(知道就行了，了解一下，但前面五种加解密模式要清楚)
多用于磁盘加密
输入：一个明文P、一个对称密钥K、一个调和值T（不需要保密，类似于磁盘扇区号），可以提供多变性，对相同明文产生不同的密文，**防止统计攻击**。
# 流密码
OTP：One-time pad cipher，使用一个随机的流密码$k$，加密$c←m \oplus k$。要求：
1. 这个流密码只能用一次，否则密钥k会泄露。
2. 这个流密码长度$|k| \geq |m|
最大的问题是如何进行Key Generation,找到一个KG算法，使得$k←KG(seed)$，且k满足上述要求。可以使用迭代的方式，$l←KG(KG(...KG(seed)))$
注：AES使用OFB模式时，可以做到和流密码相同的效果。
## 随机数
保密系统的保密能力还取决于随机数的质量。
多用于：
1. 会话密钥[需要加密]
2. 公钥的pq值[需要加密]
3. 挑战响应认证[不加密]
4. 防重放攻击的NONCE[不加密]
5. 口令保护的随机数值[salt,不加密]，$pwd'=Hash(pwd,salt)$
### 随机数质量要求
1. 均匀分布：0/1出现概率各半;0-255出现概率1/256...
2. 无周期，无法预测和推导
3. 无理数($\pi 、e$)
### 伪随机数
周期很大，类似一个随机数
##### 真随机数
不实用，可以使用物理方法（热运动等）或专用硬件（Intel Random Generator）产生。
生成后可能随机源存在偏差，需要使用哈希函数(Md5、Sha-1)等消除。
##### 伪随机数发生器PRNG
1. 三大公设(了解)：01个数相差最多为1，每个长度序列（游程）的01数量相同。异相自相关系数是常数（序列和自己平移后的序列对比，找不到信息）
2. $random_y ← PRNG(seed)$，$seed$是一个短值,产生一个长度很长的$random_y$，且周期很长。
###### 简单线性同余方法
迭代思想
1. $X_0=seed$
2. $X_{i+1} = (aX_i+b) \mod m$，m是一个常数
- 基本要求是能够通过随机性测试、且周期为m。
- 若m为素数，则合理选择a，就可以做到周期为m-1:$X_{i+1}=aX_i \mod m $。
- IBM算法：$a=7^5,m=2^31-1(素数)$
- 线性函数选定$x_0$后，就可以预测所有$x_i$。如果得到确定的$x_0、x_1，x_2$（即三个随机数）通过扩展欧几里得算出$a、m、b$
###### BBS PRNG
仍旧同余，但使用乘法（平方）运算，选取的n特别大。
1. $x_0=seed,n=pq,p/q = 4k+3$，即pq在模4下同余3
2. $x_i=x_0^2 \mod n$
3. 取$x_i$最低比特位进行输出。
- 预测复杂度类似于离散对数问题。
- 运算效率慢（因为n非常大）
###### 基于分组密码的PRNG构造
使用安全的分组密码如CTR、OFB模式进行构造。
选定一个seed的K，返回轮询加密比特1
###### 基于移位反馈寄存器的方式
是一种重要的钟控单元。
一个固定长度的队列，按照某种规则和时钟节拍（钟控信号）来进行移位，并进行出列（输出）和补列（状态更新）。

# 哈希函数
使用的是**密码**哈希函数，比一般数据结构的哈希函数要求严格得多。
## Hash函数性质
使用Hash函数，有时也称为消息摘要Message Digest、数字指纹Digital Fingerprint。生成相同长度的摘要输出。**输入长度可变而输出长度相同**，一般128/160比特，效率高。表征该数据特征。**多个输入可能对应同一个输出，但同一个输入一定对应同一个输出**。
### 散列函数的要求
1. 单向性（抗原像攻击）：快速计算出H(M)，但构造逆函数$H^-1(M)$不可行，**求逆困难**。  
2. 抗冲突性(碰撞)：弱抗碰撞(抗第二原像攻击)：给定M，计算上给不出M'，使H(M)=H(M')；强抗碰撞：找不出任何一对M,M'，使H(M)=H(M')
3. **抗碰撞的强度是长度一半**(128位散列值抗64位冲突，$2^{64}$次操作后才冲突)
4. 改变消息的任何一位，会导致Hash结果大部分改变。满足伪随机性测试的条件。
### 如何寻找碰撞？生日攻击。
利用概率学的经典问题：教室中的所有人，存在有相同生日的两个人，概率超过一半只需要23人。即存在碰撞的概率大。
## 目前有的函数
CRC:很难检测出流的比特改变、奇偶校验码：只能检测出奇数个错误，不满足单向性等性质。
MD2/MD5：已经不使用，被差分分析后强抗碰撞被攻破。
SHA/SHA-1：不使用
SHA-256/SHA3...
## 构造Hash函数
### 基于分组加密算法CBC-MAC
1. $H_0=$初始值IV
2. $H_i=E(M_i,H_{i-1})$
3. 输出$G=H_n$
类似不带密钥的CBC加密。CBC-MAC
##### 安全性
分组密码需要padding，在padding数据中加入padding长度和原信息长度。padding后使用CBC模式加密即可。
###### 穷举攻击
如果输出n比特的Hash值，则：
1. 抗原像攻击（单向性）：$2^n$，需要全部遍历
2. 抗第二原像攻击（弱碰撞）：$2^n$
3. 抗强碰撞攻击：$2^{\frac{1}{2}}$  
### 安全哈希函数SHA结构
Secure Hash Algorith:SHA
MD2、MD5、SHA、SHA-1、SHA-256等使用使用结构
#### 基本结构
![alt text](image-25.png)
功能：将定长的抗碰撞Hash函数转换为变长的抗碰撞Hash函数。
1. 设计一个压缩函数h，要求效率高、抗碰撞、较小等
2. 将消息分块并padding，并增加一块表示padding长度和消息长度等。
3. 经过SHA精心设计的多轮Hash，得到最终Hash结果。
- 注意：**IV可以重用**，是一个常量。
- 和分组加密的方式有本质不同，且效率比分组加密的Hash高。
#### MD5
![alt text](image-26.png)
## Hash函数作用
可以用于发布软件时的校验和（ChunkSum，是公开的）。OpenSSLo使用了SHA-1和SHA-256函数。可以判断是否被中途修改。
### 消息认证
确认消息完整性。 
![alt text](image-22.png)
![alt text](image-23.png)
Hash比加密快得多。若不需要加密，则2方案比1、4好。
1. 对明文m作Hash摘要，**对称会话密钥**加密后放入明文消息；接收到后解密摘要，对比明文的Hash值。**仅保证完整性**
2. 对明文m作Hash摘要，拼接m|Hash后**对称密钥加密整个拼接后的信息**。接收到后解密整个值。**保证完整性和机密性**
3. 由于Hash比加密快得多，所以考虑不使用加密，而使用一个双方共享的秘密值S，在传输时在M后拼接S计算Hash值，传输时传输M|H；收到后接收方也使用M|S计算Hash值，与H对比。
4. 也可以在共享秘密基础上加上K对称加密，用来保证机密性。但**不能使用对称密钥K来作为共享秘密**，即$E_k(M,Hash(H|K))$，存在微妙的问题，了解即可。
#### 消息认证码MAC
Message Authentication Code:MAC，可用于认证消息完整性，生成一个Hash值。
1. HMAC：带有密钥的MAC码。
  - 普通HMAC：![alt text](image-27.png)
  - 优化HMAC：
  - HMAC安全性：依赖于组件安全性。可能攻击算法本身或Hash函数。 
2. CMAC：利用DES-CBC，增加两个密钥，便于处理变长数据
3. 数据认证算法DAA：目前已停用。基于DES与CBC。看看就得了。
### 数字签名(身份认证)
与消息认证类似。将一个Message使用Hash进行压缩后使用私钥签名。解密使用公钥，公钥分发时使用可信任机构如CA（Certificate Authentic，认证机构）等颁发的公钥证书，可以做到身份认证。
使用Hash函数功能：压缩便于签名（加快公钥加密速度）、打破统计特征。
![alt text](image-24.png)
### 生成单向口令文件
如在操作系统中存储口令的Hash值摘要。password:pw=Hash(pw)。
安全要求：q次尝试中从Hash(pw)中恢复pw的难度和q次内直接尝试找到pw的难度一样大。 
为了确保短密码的抗冲突性，可以加入随机数盐值salt，计算Hash(salt,Password,salt)。不一定保密但是需要随机。、
### 存储云端文件
## 和加密（数据机密性）的不同
##### 被动敌手：加密
对于一个敌手Adversary，想要窃听和分析。加密的目的是**抗消息窃取**和**一定程度的流量分析**。
加密不能完全隐藏，知道在通信，但不知道具体协议和通信内容。仍然可以通过如数据流量大小communication size等猜测（可以使用不同加密模式处理，但仍然难以解决；流密码长度易被侦测）。这就称为leaking。
##### 主动敌手：认证
对于一个敌手，可能还会伪造、篡改、重放、拒绝服务攻击。这破坏了**数据完整性**。需要Hash函数。
### 应用实例（了解）
##### CCM消息认证
基于Counter和AES。首先将数据和nonce头拼接，分块后进行CMAC。之后加密
![alt text](image-28.png)
##### GCM
可以做多线程的优化。
![alt text](image-29.png)
### 后面就快速过一下
#### 密钥封装
KW Key Wrap
使用AES或3DES作为加密基础，使用预共享的对称密钥交换其他对称密钥，有鲁棒性
#### 使用哈希函数或MAC生成伪随机函数
例如使用一个计数器，一直向Hash函数中输入，输出随机数；
或使用HMAC，一个Key+计数器。
# 公钥加密
从古典密码到DES，都是使用了替换和置换等方法。
而Diffle-Hellman提出了公钥思想D-H交换。可以实现加密、认证。
## 思路
对称密钥难以协商，且需要过多密钥；可以通过算法得到一对公私钥对$P_k,S_k$（是两个大数），要求不能通过$P_k$恢复出$S_k$。实际上计算量过大难以实施。
目前使用的是**混合加密模式**，并不是说对称加密模式不好。
## 用处
### 保密
a发送m明文：$Enc(pkb,m)=c$，b解密$Dec(c,skb)=m$
### 数字签名
a发送m明文：$Sign(ska,m)=\sigma$、$Verify(pka,m,\sigma)$。进行签名后，只有拥有私钥$ska$的才能加密，所以认证了身份。
#### 安全性
攻击者可以尝试恢复私钥，或通过得到的多个$\sigma$进行伪造一个新的$\sigma ^ *$
### 同时保密和签名
用$pkb、ska$进行签名和加密。
## 构造公钥体系
### 单向函数
#### One-way Function生成密钥对
目的：一个函数，得到$H=f(x)$很容易，而逆函数$x=f^{-1}(H)$计算很难。这个函数就是使用公钥进行加密。
#### 单向陷门函数
如果得到了某个陷门（秘诀），则x恢复很容易。这个陷门就是私钥。
#### 具体函数：整数分解假设
##### 整数分解实现
定义一个PPT算法GenModulus($1^n$)，输入n，输出一个N=pq（pq为素数）。
定义实验

给定n、算法GenModulus。
1. 生成(N,p,q)。
2. 敌手选择p'q'=N
3. 判断p'=p,q'=q，则输出1，否则输出0。

大整数分解难度在于：敌手获胜的概率小到可以忽略。
##### RSA假设
定义一个PPT算法GenRSA（$1^n$）=(N,e,d)，N为两个n比特素数e、d的乘积。$gcd(e,\Phi(n))=1$且$ed = 1 mod \Phi(N)$
定义实验：

给定敌手A和安全参数n。
1. 生成(N,e,d)
2. 均匀随机选择y(y \in Z^*(N))
3. 敌手A给定一个N,e,y，输出一个x；
4. 若x^e = y mod N，则输出1，否则输出0


###### 如何构造GenRSA
1, (N,p,q) ← GenModulus(1^n)
2. $\Phi(N) =（p-1）（q-1）$
3. 选择一个e，使得
4. 计算d 
返回(N,e,d)
#### 具体实现：离散对数假设Elamal
一个循环群生成算法：$g(1^n) → (G,q,g)$G是一个循环群、q是阶数、g是生成元。

### Diffle-Hellman密钥交换协议
不抵抗中间人攻击
ab双方共享g、q两数。
1. a生成一个$x_a$数字，b生成一个$x_b$数字。
2. a发送$g^a mod q$,b发送$g_b mod q$
3. 最终使用$g^ab mod p$进行通信
## RSA
**基于RSA假设，而不是大整数分解假设**。RSA假设是大整数分解假设的变体。
### 密钥生成流程
1. 选取两个512bit素数p、q
2. 计算N=pq
3. 计算$\Phi(N) = (p-1)(q-1)$
4. 选择公钥e，要求与$\Phi(N)$互素，$gcd(e,\phi(N))=1$
5. 计算私钥d，使得$de mod \Phi(N) =  1$；在mod N下求e的乘法逆，使用拓展欧几里得。
发布公钥(e,N)，私钥保密(d,N)
### RSA加解密
1. 加密$c=m^e  mod N$
2. 解密:$m = c^d mod N$
加解密时可以使用中国剩余定理加速。
##### RSA加解密正确性分析
$c^d mod N$一定为m。
### 如何选择素数p、q？
长度必须足够长。不能使用试除、Rabin-Miller。
### RSA攻击
#### 枚举
1. 枚举所有可能明文m，用公钥加密，与c对比。
2. 枚举所有可能的私钥d（已知明文）
#### 数学方法
1. 分解N=pq
2. 直接求$\Phi(N)$，再求私钥d
3. 直接尝试求解d
#### 安全性
##### 大整数分解算法
尝试分解N。是一个NP问题。消耗时间极大。要求N足够大。
##### 猜测随机数pq
1. 产生pq时一定要不可预测，密码上要足够安全。
2. 若$e<n$且$d < n^{\frac{1}{4}}$，则$d$很容易被猜测出来
##### pq之间关系
1. |p-q|一定要大：
    1. 计算$\frac{(p+q)^2}{4}-n=\frac{(p-q)^2}{4}$
    2. 若|p-q|很小，则上述式子也很小。遍历所有$>n^{\frac{1}{2}}$的数，可以穷举出n=(x+y)(x-y)
2. p-1、q-1需要有大素因子，否则有重复加密攻击
####  实际攻击
##### 共模攻击
如果每个用户都使用同一个模数N，仅仅改变公钥e的取值，则存在共模攻击。使用中国剩余定理计算出明文。
##### 低指数攻击
选取的e指数小，可以通过中国剩余定理计算。
##### 同态特性
因为$c_1=m_1^e mod N$、$c_2=m_2^e  mod N$。则$c_1 × c_2 = Enc(m_1 × m_2)$
可以让云计算服务器直接计算密文，而服务器不知道具体数据，返回后仍然可以解密出正确计算结果。
为了防止攻击，可以在RSA加密时填充随机数。
###### 最优对称填充OAEP
RSA本身对于相同明文$m_1、m_2$加密的密文相同，可能存在统计分析等问题。
加入最优对称填充，增加某些随机性。
### RSA作用
###### 加解密
###### 做认证
###### 传递会话密钥
RSA加密速度太慢，还是对称密钥好。
## ElGamal
基于**DDH假设**。可能是基于DLP离散对数假设？（没听懂）
构造一个循环群。
循环群生成算法：$g(1^n) → (G,q,g)$G是一个循环群、q是阶数、g是生成元。
### 密钥生成
![alt text](image-30.png)
注意：解密方法中的除法是在求逆元。
$h=g^x,c2=g^{xy} · m$
### 安全性
概率性的算法，概率多项式时间的算法，引入了随机性（随机选取y）。
为什么是安全的？
1. 对于一个敌手，得到了公开信息G、q、g，公钥$g^x$,$c_1=g^y$，和一个$g_z$，但这个$g_z$实际上是$g_{xy}$，但这个敌手无法判断出$g_z = g_{xy}$
### 效率和优势
1. m要编码为群G上的元素。
2. 一个密文会扩张为两倍大小(c1,c2)
3. 参数g、q、g等重复使用是可以的。
## 椭圆曲线
使用较小的密钥长度达到较高的计算难度。方程式和椭圆求周长类似。
基于ECDLP：椭圆曲线EC上的离散对数DLP问题。
### EC
##### 基础式子
$y^2 + axy + by = x^3 + cx^2 + dx + e$
其中abcde是满足条件的实数。
定义一个O点（无穷远点）
##### 化简式子
一般将上式化简为：$y^2 = x^3 +ax +b mod p$(一个素域)。不用记通常会给。
##### 曲线加减法
曲线关于x轴对称
www.desmos.com
1. 加法：椭圆上两个点$P(x_1,x_2)Q(x_3,x_4)$，P+Q表示PQ两点连线在椭圆曲线上的交点与x轴的对称点坐标。
2. 乘法：
   1. 如2A=A+A，则PQ两点无限接近与A，就是切线在曲线上的另一个交点关于x轴的对称点。3A就是先求2A所在交点，用这个焦点再和A连线。
   2. kA很难计算。如果没有一步一步生成的连线，则很难算出曲线上的某一点E是A的多少倍。**是椭圆曲线密码的数学困难问题**。
3. 计算焦点方法：
   1. 对于PQ两点，直到PQ、且焦点x在椭圆上，则y的值可以通过计算Px、Qx之间斜率相等的方程求出来。x值可以通过带入y求出来。
   2. ![alt text](image-31.png)
   3. ![alt text](image-32.png)
### 密钥交换
对于$y^2 = x^3 +ax +b mod p$，选择素数p（大小约为160+比特），a、b
1. 选择一个生成点$G(x_1,y_1)$。公开a、b、G
2. A选择秘密$N_a$，计算$P_a=N_a × G$
3. B选择秘密$N_b$，计算$P_b=N_b × G$，这个过程就像是将一个在某个位置的足球踢若干脚，但攻击者不知道。
3. 交换$P_a、P_b$。计算K=$N_a × N_b × G$,K'=$N_b × N_a × G$。类似一个DH交换。
### 加解密方案
![alt text](image-33.png)
原理：先通过$P_m+k×P_b$掩盖$P_m$，在通过$k×G$掩盖$k$。只要知道陷门$N_b$就可以解密。
### 效率速度
密钥长度相等，RSA和ECC加密速度一样
但为了达到相同安全性，ECC可以选择更短的参数

## 总结
公钥更灵活适用于更多场景，但达到相同安全要求下，效率比对称更低。多用混合加密的方式。

# 数字签名
## 概述
### 对称/非对称加密做认证的区别
![alt text](image-34.png)
### 数字签名概述
用于抗抵赖且表明身份。
对于对称密码进行认证算法，如HMAC，虽然可以确定key相同认证完整性，但可能存在中间人攻击，共享的对称密钥k可能是发送方接收方AB共享的，也可能是AB与中间人相互共享的，**不存在身份认证功能**。
- 为什么抗抵赖？公钥文件由CA证书授权机构分发，而CA是可信的。是一种基于可信第三方的认证方式。**一种信任转移，有可转移性**
##### 数字签名一般模型
1. 发送方使用密码学Hash函数Hash明文信息m得到H
2. 发送方用**自己的私钥加密H**
3. 发送$m|s_k(H)$
4. 接收方接收到$m|s_k(H)$后用**发送方公钥$p_k$**解密出H，将m计算一个Hash值H'并于H对比。
##### 使用Hash函数的原因
1. Hash又称为压缩函数，将原m压缩为更短的H，提高签名/验签、加密/解密效率。又降低了通信开销。
2. 提升一定程度的安全性。
##### 数字签名要求
1. 签名一个大文件，生成一个小文件签名
2. 必须包含一个发送方独有信息（类似指纹、虹膜等）
3. 产生、验证签名简单，在多项式时间内完成。
4. 对已知的数字签名再构造一个新消息不可能、对已知消息构造一个伪造的数字签名不可能
## 典型数字签名方案
### RSA签名
不使用Hash而直接使用私钥加密，不安全。
##### 签名过程
计算一个N、e、d。公钥为(N,e)、私钥为(N,d)
签名：$\Sigma = [m^d mod N]$
验签：$m = \Sigma^e mod N$
##### 安全性
存在**无消息攻击**和伪造任意签名攻击
可以伪造任意消息的签名。利用RSA的**同态性质**。
1. 给定任意消息$m \in Z_p^*$
2. 选择任意消息$m_1$，令$m_2 = \frac{m}{m_1} mod N$。A发送$(m_1,m_2)$给签名者。得到$(m_1,\Sigma_1),(m_2,Sigma_2)$
3. 令$\Sigma = \Sigma_1 · \Sigma_2 mod N$，则这个$\Sigma$就是m的签名。
### RSA-FDH签名
FDH：Full Domain Hash。将m进行Hash后再进行私钥加密
一但使用了，则存在单向性，解决了无消息攻击问题和伪造签名。
##### hash函数安全性
若Hash函数是一个真随机，那安全。但实际上找不到，只能是相对安全。
### ElGamal签名
![alt text](image-35.png)
记忆：先有下面的验证veri算法，再往上计算签名算法。
![alt text](image-36.png)
##### 优点
安全
##### 缺点
签名长度是明文两倍
### Schnorr
基于IP Scheme方案构造Sig。不做实际要求。
![alt text](image-37.png)
### DSS数字签名标准+DSA数字签名算法
Digital Signiture Standard/Algorithm
增加一个随机数，在加密时使用私钥$s_k$+一个随机数$k$
![alt text](image-38.png)
![alt text](image-39.png)
### 椭圆曲线上的数字签名ECDSA
![alt text](image-40.png)
### RSA-PSS
RSA-FDH仍然是一个确定性签名，而RSA-PSS是随机性的。
![alt text](image-42.png)
![alt text](image-41.png)
## 数字签名升级（前沿知识）
算法不要求掌握，但可以了解一些知识。
### 一些变种
#### 签名者限制
##### Alice不能知道自己将要发送的信息是什么-盲签名
消费者消费时希望使用电子货币，而需要银行（权威机构）的签名，但不希望银行知道我消费了多少钱。可以将用户的消费请求信息盲化。
例如RSA中，发送Hash(m)时增加一个随机数的r^e，由于RSA的同态性，签名后可以直接乘以$r^{-1}$还原。
##### Alice能控制验签过程，只有部分人能验签-不可否认签名
没有签名者的帮助无法验签，且签名者无法否认一个有效签名。
例如A发布的软件包卖给B，A帮助B验签。
B又将软件包卖给C，而C没有A的帮助无法验签。除非B重新用自己的签名，但这样就会损害B的名誉。
###### 验签方式
有签名算法、验签协议、否认协议。
A可以否认签名，拒绝参与签名。而一旦参与了，就可以使用否认协议进行验证真伪。
签名者还可以委托某方作为验证者。
$Verify(A_input,B_input)$
###### 变色龙签名
先Hash再sign，但使用变色龙Hash，只要找到了陷门就能找到Hash的碰撞。
若知道陷门，就可以找到Hash(m,r)=Hash(m',r')。
- 有不可转移性：所有人都有Pk，所有人都能相互传播并验签，具有转移性。而如果发布签名者A直接将陷门发送给验证者(用户)B，那么B一定能构造出一个虚假的签名m',r'，则没有人(其他用户C)会相信B发送给他们的软件，只有A签名者本人发送的才行。
##### 让一个不知道私钥的第三方来帮助我签名-代理签名
- 要求：
  1. 代理人签名和本人签名一致
  2. 只有本人和代理人可以签名
  3. 知道是代理人签名还是本人签名
#### 验证者限制
##### Bob不能独立验证签名有效性-门限验证签名
需要其他**验证者**才能进行签名。
只有集齐n个人才能验证签名...
##### Bob不知道是Alice签的名-签名者身份隐私
仅知道这个签名者是一个组的成员，但不知道是谁。存在匿名性。
###### 群签名
只有群成员能以群名义发布签名。无论是谁都不能伪造签名。
一旦出现争端，群管理员可以追踪到是谁签的名。
###### 环签名
完全匿名，不会被管理员揪出来。多个人形成一个环进行签名，没有预先建立过程，无组织者，无中心。
##### 属性签名
公钥pk是一个属性，有一个函数f(pk)，仅当f(pk) = 1时，签名者才能签名。
##### Bob能对ALice签名的消息进行处理
###### 同态签名
允许在一定程度上的修改
###### 净化签名
签名m"允许贷款X万元"，且本签名仅在X<50时生效。
# 密钥管理
## 对称密钥分配基本方法
1. 对称密钥用于传统密码体制的密钥分配
2. 公钥体制用于传统密码体制的密钥分配:存在机构：证书体系CA。
### 演进
1. A和B通过物理手段交换
2. 选择第三方服务器S，S生成密钥发送给AB。服务器的密钥使用物理方式发送。
3. 新密钥用旧密钥加密：使用加密长期密钥加密会话密钥进行分享。泄露加密密钥则破坏安全性。
4. 密钥分发中心：Key Distribute Centre。每个用户和KDC拥有一对对称主密钥（用2方法交换），KDC为两个用户AB生成共享密钥，使用AB的主密钥发送给AB。 
  - 只需要n对主密钥；而会话密钥仍然是$n(n-1)/2$
### 基于对称密钥的密钥管理体制
##### 无中心
用户之间交换，$n(n-1)/2$
##### 第三方密钥交换
减少密钥分发代价：将分布式结构转变为中心式结构
![alt text](image-43.png)
![alt text](image-44.png)
##### 密钥分层管理
降低分发开销、满足不同协议对层次结构密钥的要求。
![alt text](image-45.png)
### 基于公钥体制的密钥管理体制
由于对称密码效率更高，所以选择使用公钥体制来传递对称会话密钥，而用会话密钥加密通信。
#### Merkle方案
$A -> (KU_a || ID_a) -> B$。$KU_a$是A自己的公钥。
$B -> (E_{KU_a}(K_c) -> A)$。$K_c$是会话密钥。
存在中间人攻击。
#### NEED78方案
需要事先共享双方公钥。
![alt text](image-46.png)
$N_i$是某个随机数。
## 公钥分配基本方法
#### 自由方式
1. 通信时临时要求。无法进行身份认证。临时加密。
2. 扩散：将某人的公钥通过好友等进行转发，需要确保好友是可信的，例如PGP协议就是用了这个技术。
#### 公开目录
- 目录需要由可信实体(安全中心)来维护。
- 每个用户都在目录里存有{id,公钥}
- 面对面审核和注册
- 可以更新和废止
- 可以公开查询
给安全中心带来极大负担
![alt text](image-47.png)
#### 离线中心：证书认证中心CA
![alt text](image-48.png)
##### X.509证书
是基于公钥密码体制和数字签名的标准
![alt text](image-49.png)
###### 证书格式
版本、序列号、算法标识和参数、签发者名字、持有者标识、生存周期等、扩展等。
##### CA
审核身份、签发证书。
###### 证书自证明和应用
1. 前提：有CA公钥。一般是自签名证书，可靠的获得，如手工获得或系统预置。
2. 证书公开不用保密，使用CA公钥来验证别人的证书中CA进行的签名，由于信任CA，所以信任此人。
3. 确认证书是可信且未被篡改。
###### CATree
相互达成信任。通过节点连接达到全局可信。
![alt text](image-50.png)
##### 证书撤销
如果证书被修改或身份改变、生存周期过等。
#### PKI：公钥基础设施
包括多个设施组织起来的基础设施，支撑整个公钥系统。
## 简单介绍几个东西
### 秘密共享
门限秘密共享：讲一个秘密S分成k份，给n个人，至少需要k个人一起才能获得秘密S。分散风险。
用的多的：Shamir的门限秘密共享。
### 轻量级密码
### 后量子密码

























